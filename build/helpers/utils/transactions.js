"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySignMsg = exports.verifySignature = exports.generateTxBytes = exports.generateSignature = exports.generateSignDocBytes = exports.generateSignDoc = exports.generateAuthInfoBytes = void 0;
const long_1 = __importDefault(require("long"));
const math_1 = require("@cosmjs/math");
const crypto_1 = require("@cosmjs/crypto");
const proto_signing_1 = require("@cosmjs/proto-signing");
const encoding_1 = require("@cosmjs/encoding");
const tx_1 = require("../../codegen/cosmos/tx/v1beta1/tx");
const signing_1 = require("../../codegen/cosmos/tx/signing/v1beta1/signing");
const constants_1 = require("../constants");
const commons_1 = require("./commons");
const encoding_2 = require("./encoding");
const keys_1 = require("./keys");
const registry_1 = require("../registry");
/**
 * Generate transaction auth info payload
 *
 * @param docSigners Document signers
 * @param fee requested fee
 * @param signMode signing mode
 */
const generateAuthInfoBytes = (docSigners, fee, signMode) => {
    const authInfo = {
        signerInfos: docSigners.map((signer) => ({
            publicKey: (0, keys_1.publicKeyToProto)(signer.publicKey),
            modeInfo: {
                single: { mode: signMode },
            },
            sequence: long_1.default.fromNumber(signer.sequence),
        })),
        fee: {
            amount: [...fee.amount],
            gasLimit: long_1.default.fromNumber(math_1.Int53.fromString(fee.gas).toNumber()),
        },
    };
    return tx_1.AuthInfo.encode(tx_1.AuthInfo.fromPartial(authInfo)).finish();
};
exports.generateAuthInfoBytes = generateAuthInfoBytes;
/**
 * Generate transaction doc to be signed
 *
 * @param doc document to create the sign version
 * @param signerIdx index of the signer in the signers field used to specify the accountNumber for signature purpose
 * @param signMode signing mode for the transaction
 */
const generateSignDoc = (doc, signerIdx, signMode) => {
    if (signerIdx < 0 || signerIdx > doc.signers.length) {
        throw new Error('Invalid doc signer index');
    }
    const txBody = {
        messages: doc.messages,
        memo: doc.memo,
    };
    const bodyBytes = registry_1.LumRegistry.encode({
        typeUrl: '/cosmos.tx.v1beta1.TxBody',
        value: txBody,
    });
    return {
        bodyBytes,
        authInfoBytes: (0, exports.generateAuthInfoBytes)(doc.signers, doc.fee, signMode),
        chainId: doc.chainId,
        accountNumber: long_1.default.fromNumber(doc.signers[signerIdx].accountNumber),
    };
};
exports.generateSignDoc = generateSignDoc;
/**
 * Generate transaction sign doc bytes used to sign the transaction
 *
 * @param signDoc sign doc (as generated by the generateSignDoc function)
 */
const generateSignDocBytes = (signDoc) => {
    return (0, proto_signing_1.makeSignBytes)(signDoc);
};
exports.generateSignDocBytes = generateSignDocBytes;
/**
 * Generate transaction signature
 *
 * @param hashedMessage sha256 hash of the sign doc bytes (as generated by the generateSignDocBytes function)
 * @param privateKey private key used to sign the transaction (secp256k1)
 */
const generateSignature = async (hashedMessage, privateKey) => {
    const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privateKey);
    return new Uint8Array([...signature.r(32), ...signature.s(32)]);
};
exports.generateSignature = generateSignature;
/**
 * Generate transaction bytes to broadcast
 *
 * @param signDoc sign doc (as generated by the generateSignDoc function)
 * @param signatures transaction signatures (as generated by the generateSignature function)
 */
const generateTxBytes = (signDoc, signatures) => {
    const txRaw = tx_1.TxRaw.fromPartial({
        bodyBytes: signDoc.bodyBytes,
        authInfoBytes: signDoc.authInfoBytes,
        signatures: signatures,
    });
    return Uint8Array.from(tx_1.TxRaw.encode(txRaw).finish());
};
exports.generateTxBytes = generateTxBytes;
/**
 * Verify that a signature is valid
 *
 * @param signature signature (as generated by the generateSignature function)
 * @param signedBytes signed bytes (as generated by the generateSignDocBytes function or by the signMessage function)
 * @param publicKey public key of the signing key pair (secp256k1)
 */
const verifySignature = async (signature, signedBytes, publicKey) => {
    return crypto_1.Secp256k1.verifySignature(crypto_1.Secp256k1Signature.fromFixedLength(signature), (0, encoding_2.sha256)(signedBytes), publicKey);
};
exports.verifySignature = verifySignature;
/**
 * Verify that a message is signed by the provided publicKey
 * Will also verify that the address is indeed derivated by the provided publicKey
 *
 * @param msg Message to verify such as generated by the LumWallet.signMessage method
 */
const verifySignMsg = async (msg) => {
    const { prefix } = (0, encoding_1.fromBech32)(msg.address);
    if ((0, keys_1.getAddressFromPublicKey)(msg.publicKey, prefix) !== msg.address) {
        return false;
    }
    if (msg.signer === constants_1.LumMessageSigner.PAPER) {
        return (0, exports.verifySignature)(msg.sig, (0, encoding_1.toAscii)(msg.msg), msg.publicKey);
    }
    else if (msg.signer === constants_1.LumMessageSigner.OFFLINE) {
        const signDoc = {
            bodyBytes: (0, encoding_1.toAscii)(msg.msg),
            authInfoBytes: (0, exports.generateAuthInfoBytes)([{ accountNumber: 0, sequence: 0, publicKey: msg.publicKey }], { amount: [], gas: '0' }, signing_1.SignMode.SIGN_MODE_DIRECT),
            chainId: constants_1.LumSignOnlyChainId,
            accountNumber: long_1.default.fromNumber(0),
        };
        const signedBytes = (0, exports.generateSignDocBytes)(signDoc);
        return (0, exports.verifySignature)(msg.sig, signedBytes, msg.publicKey);
    }
    else if (msg.signer === constants_1.LumMessageSigner.LEDGER) {
        // Re-generate ledger required amino payload to sign messages
        // This is basically an empty transaction payload
        // Same a used in the LumLedgerWallet > signMessage method
        const msgToSign = {
            'account_number': '0',
            'chain_id': constants_1.LumSignOnlyChainId,
            'fee': {},
            'memo': msg.msg,
            'msgs': [],
            'sequence': '0',
        };
        return (0, exports.verifySignature)(msg.sig, (0, encoding_1.toAscii)(JSON.stringify((0, commons_1.sortJSON)(msgToSign))), msg.publicKey);
    }
    throw new Error('unknown message signer');
};
exports.verifySignMsg = verifySignMsg;
//# sourceMappingURL=transactions.js.map